#!/usr/bin/env python

from sys import argv, stdout, stderr
from collections import Counter
from copy import deepcopy
from getopt import gnu_getopt, GetoptError
from multiprocessing import Pool
import pysam as ps
import numpy as np
import re

# global paramaters I do not expect to be changed for now
UMITHRESHOLD = 9
COVERAGETHRESHOLD = 4
AGREEMENTTHRESHOLD = 0.9
CONSENSUSNTHRESHOLD = 0.1
MAXTEMPLATELENGTH = 300
PADDING = 0

# An assumption here is that most pairs overlap, and hence I would not 
# have Ns in the consensus in families.

def infer_read_len(cigar):
    ops = re.findall('[\d]{0,}[A-Z]{1}', cigar)
    alen = 0
    for op in ops:
        if op[-1] in ['M','D']:
            alen += int(op[:-1])
        assert op[-1] not in ['N','H','P','=','X','B']
    return alen

def ignore_alignment(aln):
    """Should I ignore this alignment?"""
    global MAXTEMPLATELENGTH
    if aln.is_unmapped: return True
    if aln.mate_is_unmapped: return True
    if aln.is_secondary: return True
    if aln.is_supplementary: return True
    if aln.next_reference_id != aln.reference_id: return True
    if abs(aln.template_length) > MAXTEMPLATELENGTH: return True
    return False

def pair_overlaps(aln, start, end):
    left = aln.pos
    right = aln.aend
    if left > end or right < start: return False

    alen = infer_read_len(aln.get_tag('MC'))
    left = aln.next_reference_start
    right = aln.next_reference_start + alen
    if left > end or right < start: return False

    return True

class Alignment:
    def __init__(self, aln):
        self.pos = aln.pos
        self.query_sequence = aln.query_sequence
        self.cigartuples = aln.cigartuples

class Consensus:
    """Consensus that result from alignments of the same read family."""
    def __init__(self, start, end):
        self.profile = {}

    # add a new alignment to the profile
    def add_alignment(self, aln):
        qseq = aln.query_sequence
        qndx = 0
        rndx = aln.pos
        for op, oplen in aln.cigartuples:
            if op == 0 or op == 7 or op == 8:
                # match / mismatch
                for i in range(0, oplen):
                    if rndx not in self.profile: self.profile[rndx] = Counter()
                    self.profile[rndx][qseq[qndx]] += 1
                    qndx += 1
                    rndx += 1
            elif op == 1:
                # insertion
                assert rndx-1 in self.profile
                self.profile[rndx-1][qseq[qndx-1]] -= 1
                self.profile[rndx-1][qseq[qndx-1:qndx+oplen]] += 1
                qndx += oplen
            elif op == 2:
                # deletion
                for i in range(0, oplen):
                    if rndx not in self.profile: self.profile[rndx] = Counter()
                    self.profile[rndx]['*'] += 1
                    rndx += 1
            elif op == 3 or op == 9:
                assert False
            elif op == 4:
                qndx += oplen
            elif op == 5:
                pass
            elif op == 6:
                assert False
            else:
                assert False

    def __str__(self):
        global COVERAGETHRESHOLD, AGREEMENTTHRESHOLD

        positions = self.profile.keys()
        s = min(positions)
        e = max(positions)

        sequence = []
        for p in range(s,e+1):
            if p in self.profile:
                profile = self.profile[p]
                alleles = [(y,x) for x,y in profile.items()]
                alleles.sort(reverse = True)
                covering = sum([x for x,y in alleles])
                agreeing = alleles[0][0]

                if covering < COVERAGETHRESHOLD:
                    sequence.append(".")
                else:
                    if (agreeing*1./covering) >= AGREEMENTTHRESHOLD:
                        b = alleles[0][1]
                        if b != '*':
                            sequence.append(b[0])
                    else:
                        sequence.append('N')
            else:
                sequence.append(".")

        return "".join(sequence)

def overlaps(a, b):
    if a[0] is None: return False
    if a[0] != b[0]: return False
    assert a[1] <= b[1], "%s :: %s" % (a, b)
    if b[1] >= a[2]: return False
    return True

def process_interval(intervals):
    return _process_interval(*intervals)

def count_per_umi(ignore_left, left, center):
    bamfile = ps.AlignmentFile(argv[1], 'r')
    chrom, start, end = center
    region = "%s:%d-%d" % (chrom, start, end)

    umi_families = Counter()
    num_reads = 0
    reference_id = None
    for aln in bamfile.fetch(region=region):
        # ignore alignment if it is unmapped, secondary, supp or insert length
        # appears inconsistent with expecation
        if ignore_alignment(aln): continue

        if ignore_left:
            # does this alignment and its pair align to the left region. If yes,
            # the thread responsible for that region should process these.
            assert left[0] == center[0]
            if pair_overlaps(aln, left[1], left[2]): continue

        # does this read and its pair overlap this region?
        if pair_overlaps(aln, start, end) == False: continue

        umi = aln.query_name.split(":")[-1]
        umi_families[umi] += 1      
        num_reads += 1
        if reference_id is None: reference_id = aln.reference_id
    bamfile.close()
    return umi_families

def _process_interval(left, center):
    global UMITHRESHOLD, CONSENSUSNTHRESHOLD
    
    ignore_left = overlaps(left, center)

    # count the number of reads and pairs per umi
    umi_families = count_per_umi(ignore_left, left, center)

    # now process the region, and get the consensus sequence per umi
    family_counter = deepcopy(umi_families)
    consensus = {}
    sequences = []
    num_aligned = 0
    num_overlapping = 0
    num_checked = 0

    bamfile = ps.AlignmentFile(argv[1], 'r')
    chrom, start, end = center
    region = "%s:%d-%d" % (chrom, start, end)

    for aln in bamfile.fetch(region=region):
        # ignore alignment if it is unmapped, secondary, supp or insert length
        # appears inconsistent with expecation
        if ignore_alignment(aln): continue

        if ignore_left:
            # does this alignment and its pair align to the left region. If yes,
            # the thread responsible for that region should process these.
            assert left[0] == center[0]
            if pair_overlaps(aln, left[1], left[2]): continue

        # does this read and its pair overlap this region?
        if pair_overlaps(aln, start, end) == False: continue

        # lets get some statistics on our assumption
        if (aln.next_reference_start > aln.reference_start):
            num_checked += 1
            if (aln.aend >= aln.next_reference_start):
                num_overlapping += 1 

        umi = aln.query_name.split(":")[-1]
        if umi_families[umi] > UMITHRESHOLD:
            if umi not in consensus:
                consensus[umi] = Consensus(start, end)
            consensus[umi].add_alignment(aln)
            family_counter[umi] -= 1
            if family_counter[umi] == 0:
                seq = str(consensus[umi])
                #print umi
                #for k,v in consensus[umi].profile.items():
                #    print k,v
                counts = Counter(seq)

                nfrac = 0.0
                if 'N' in counts:
                    nfrac = counts['N']*1./sum([y for x,y in counts.items() if x != '.'])
                if nfrac < CONSENSUSNTHRESHOLD:
                    seq = seq.replace('.','N')
                    sequences.append((umi, seq))
                for k,v in consensus[umi].profile.items():
                    del[v]
                del(consensus[umi])
            num_aligned += 1

    del consensus        
    del umi_families 
    del family_counter
    return sequences

# read in all the intervals
intervals = []
with open(argv[2], 'r') as f:
    for line in f:
        chrom, start, end, _ = line.strip().split()
        start = int(start) - PADDING
        end = int(end) + PADDING
        intervals.append((chrom, start, end))
intervals.sort()

sets_of_interest = []
for i in range(0, len(intervals)):
    if i == 0:
        sets_of_interest.append(((None,None,None), intervals[i]))
    else:
        sets_of_interest.append((intervals[i-1], intervals[i]))

pool = Pool(int(argv[4]))
tmpfile = open(argv[3], "w")
for sequences in pool.imap_unordered(process_interval, sets_of_interest):
    for umi, seq in sequences:
        print >> tmpfile, ">%s" % umi
        print >> tmpfile, seq
tmpfile.close()

seen = set()
ignore = set()

with open(argv[3], 'r') as f:
    for line in f:
        if line.startswith(">"):
            umi = line.strip()[1:]
            if umi in seen:
                ignore.add(umi)
            else:
                seen.add(umi)

o = stdout
with open(argv[3], 'r') as f:
    while True:
        header = f.readline()
        if not header: break
        seq = f.readline()
        umi = header.strip()[1:]
        if umi not in ignore:
            print >> o, header,
            print >> o, seq,


